#!/usr/bin/env bash
# This scriptlet enhances the pull step that will only build
# development snapshots snaps if the latest tagged release has been
# promoted to the stable channel.  This ensures that there's always
# a revision of the stable release snap available in the edge channel
# for the publisher to promote to stable as currently the build
# infrastructure only supports build on code push (but not new tagged
# releases) at this time.
# https://forum.snapcraft.io/t/selective-checkout-check-out-the-tagged-release-revision-if-it-isnt-promoted-to-the-stable-channel/10617
# 林博仁(Buo-ren, Lin) <Buo.Ren.Lin@gmail.com> © 2018

set \
    -o errexit \
    -o errtrace \
    -o nounset \
    -o pipefail

for required_command in \
    awk \
    cut \
    sed \
    snap \
    sort \
    tail \
    tr; do
    if ! command -v "${required_command}" >/dev/null; then
        printf -- \
            'Fatal: This script requires the "%s" command in your command search PATHs.\n' \
            "${required_command}" \
            >&2
        exit 1
    fi
done

init(){
    # checkout_mode:
    # - snapshot: Build as-is
    # - release: Build the latest tagged release
    # tag_pattern_release: We assume all tags contains dots or underscores release tags
    local \
        checkout_mode \
        flag_append_packaging_version=false \
        flag_dry_run=false \
        flag_debug_tracing=false \
        flag_force_snapshot=false \
        flag_force_stable=false \
        packaging_revision \
        postfix_dirty_marker_packaging=-d \
        postfix_dirty_marker_upstream=-dirty \
        tag_pattern_beta='-beta[[:digit:]]+$' \
        tag_pattern_release='.*[._].*' \
        tag_pattern_release_candidate='-rc[[:digit:]]+$' \
        tag_pattern_stable \
        tag_prefix_release=v \
        revision_minimal_length_packaging=4 \
        revision_minimal_length_upstream=7 \
        snap_version \
        snap_version_postfix_seperator=+ \
        upstream_version

    while true; do
        if test "${#}" -eq 0; then
            break
        else
            case "${1}" in
                # Append packaging revision after snap version
                --append-packaging-revision)
                    flag_append_packaging_version=true
                ;;
                --beta-tag-pattern*)
                    if test "${1}" != --beta-tag-pattern; then
                        tag_pattern_beta="$(
                            cut \
                                --delimiter== \
                                --fields=2 \
                                <<< "${1}"
                        )"
                    else
                        if test "${#}" -eq 0; then
                            printf -- \
                                'selective-checkout: Error: --beta-tag-pattern requires one argument.\n' \
                                >&2
                            exit 1
                        fi
                        tag_pattern_beta="${2}"
                        shift 1
                    fi
                ;;
                # Enable execution tracing
                --debug)
                    flag_debug_tracing=true
                ;;
                # Don't run snapcraftctl for testing purpose
                --dry-run)
                    flag_dry_run=true
                ;;
                # Force building development snapshot regardless the status of the snap
                --force-snapshot)
                    flag_force_snapshot=true
                ;;
                --force-stable)
                    flag_force_stable=true
                ;;
                --packaging-dirty-marker-postfix*)
                    if test "${1}" != --packaging-dirty-marker-postfix; then
                        postfix_dirty_marker_packaging="$(
                            cut \
                                --delimiter== \
                                --fields=2 \
                                <<< "${1}"
                        )"
                    else
                        if test "${#}" -eq 0; then
                            printf -- \
                                'selective-checkout: Error: --packaging-dirty-marker-postfix requires one argument.\n' \
                                >&2
                            exit 1
                        fi
                        postfix_dirty_marker_packaging="${2}"
                        shift 1
                    fi
                ;;
                --packaging-revision-minimal-length*)
                    if test "${1}" != --packaging-revision-minimal-length; then
                        revision_minimal_length_packaging="$(
                            cut \
                                --delimiter== \
                                --fields=2 \
                                <<< "${1}"
                        )"
                    else
                        if test "${#}" -eq 0; then
                            printf -- \
                                'selective-checkout: Error: --packaging-revision-minimal-length requires one argument.\n' \
                                >&2
                            exit 1
                        fi
                        revision_minimal_length_packaging="${2}"
                        shift 1
                    fi
                ;;
                --release-candidate-tag-pattern*)
                    if test "${1}" != --release-candidate-tag-pattern; then
                        tag_pattern_release_candidate="$(
                            cut \
                                --delimiter== \
                                --fields=2 \
                                <<< "${1}"
                        )"
                    else
                        if test "${#}" -eq 0; then
                            printf -- \
                                'selective-checkout: Error: --release-candidate-tag-pattern requires one argument.\n' \
                                >&2
                            exit 1
                        fi
                        tag_pattern_release_candidate="${2}"
                        shift 1
                    fi
                ;;
                # Set the prefix for all release tags(default: `v`), the prefix will be stripped from snap version string
                --release-tag-prefix*)
                    if test "${1}" != --release-tag-prefix; then
                        tag_prefix_release="$(
                            cut \
                                --delimiter== \
                                --fields=2 \
                                <<< "${1}"
                        )"
                    else
                        if test "${#}" -eq 0; then
                            printf -- \
                                'selective-checkout: Error: --release-tag-prefix requires one argument.\n' \
                                >&2
                            exit 1
                        fi
                        tag_prefix_release="${2}"
                        shift 1
                    fi
                ;;
                # Set the seperator for the postfixed string in the snap version string
                # the postfixed string will be stripped before comparing with the stripped
                # uptream release version
                --snap-postfix-seperator*)
                    if test "${1}" != --snap-postfix-seperator; then
                        snap_version_postfix_seperator="$(
                            cut \
                                --delimiter== \
                                --fields=2 \
                                <<< "${1}"
                        )"
                    else
                        if test "${#}" -eq 0; then
                            printf -- \
                                'selective-checkout: Error: --snap-postfix-seperator requires one argument.\n' \
                                >&2
                            exit 1
                        fi
                        snap_version_postfix_seperator="${2}"
                        shift 1
                    fi
                ;;
                --stable-tag-pattern*)
                    if test "${1}" != --stable-tag-pattern; then
                        tag_pattern_stable="$(
                            cut \
                                --delimiter== \
                                --fields=2 \
                                <<< "${1}"
                        )"
                    else
                        if test "${#}" -eq 0; then
                            printf -- \
                                'selective-checkout: Error: --stable-tag-pattern requires one argument.\n' \
                                >&2
                            exit 1
                        fi
                        tag_pattern_stable="${2}"
                        shift 1
                    fi
                ;;
                --upstream-dirty-marker-postfix*)
                    if test "${1}" != --upstream-dirty-marker-postfix; then
                        postfix_dirty_marker_upstream="$(
                            cut \
                                --delimiter== \
                                --fields=2 \
                                <<< "${1}"
                        )"
                    else
                        if test "${#}" -eq 0; then
                            printf -- \
                                'selective-checkout: Error: --upstream-dirty-marker-postfix requires one argument.\n' \
                                >&2
                            exit 1
                        fi
                        postfix_dirty_marker_upstream="${2}"
                        shift 1
                    fi
                ;;
                --upstream-revision-minimal-length*)
                    if test "${1}" != --upstream-revision-minimal-length; then
                        revision_minimal_length_upstream="$(
                            cut \
                                --delimiter== \
                                --fields=2 \
                                <<< "${1}"
                        )"
                    else
                        if test "${#}" -eq 0; then
                            printf -- \
                                'selective-checkout: Error: --upstream-revision-minimal-length requires one argument.\n' \
                                >&2
                            exit 1
                        fi
                        revision_minimal_length_upstream="${2}"
                        shift 1
                    fi
                ;;
                *)
                    printf -- \
                        'selective-checkout: Error: Invalid command-line argument.\n' \
                        >&2
                    exit 1
                ;;
            esac
            shift 1
        fi
    done

    if test "${flag_debug_tracing}" = true; then
        set -o xtrace
    fi

    vcs_check_runtime_dependencies \
        "${PWD}"

    if test "${flag_force_snapshot}" = true; then
        printf -- 'selective-checkout: Force building development snapshots\n' >&2
        checkout_mode=snapshot
    elif test "$(vcs_detect "${PWD}")" = not_found; then
        printf -- 'selective-checkout: Build from source archive\n' >&2
        checkout_mode=snapshot
    elif vcs_is_dirty "${PWD}"; then
        # If tracked files are modified
        # or staging area not empty
        printf -- 'selective-checkout: Working tree is dirty, building development snapshot with additional changes\n' >&2
        checkout_mode=snapshot
    elif ! \
        vcs_has_release_tags \
            "${PWD}" \
            "${tag_pattern_release}"; then
        printf -- \
            'Warning: No release tags found, assuming building from development snapshots.\n' \
            1>&2
        checkout_mode=snapshot
    else
        local \
            all_release_tags \
            release_type_to_build=development-snapshot \
            flag_version_mismatch_stable=false \
            flag_version_mismatch_beta=false \
            flag_version_mismatch_release_candidate=false \
            last_beta_tag \
            last_beta_version \
            last_beta_version_on_the_snap_store \
            selected_release_tag \
            selected_release_version \
            selected_snap_channel_version

        local -A \
            map_of_normalized_version_to_tag \
            map_of_release_type_to_snap_channel

        map_of_release_type_to_snap_channel=(
            [stable]=stable
            [release-candidate]=candidate
            [beta]=beta
            [development-snapshot]=edge
        )

        if ! test -v SNAPCRAFT_PROJECT_NAME; then
            printf -- \
                "selective-checkout: Error: This script requires SNAPCRAFT_PROJECT_NAME environment variable set to the snap's identifier.\\n" \
                >&2
            exit 1
        fi

        all_release_tags="$(
            vcs_query_release_tags \
                "${PWD}" \
                "${tag_pattern_release}"
        )"

        local normalized_release_version
        for tag in ${all_release_tags}; do \
            normalized_release_version="$(
                tr _ . <<< "${tag}" \
                    | sed "s#^${tag_prefix_release}##"
            )"

            map_of_normalized_version_to_tag[${normalized_release_version}]="${tag}"
        done
        unset \
            normalized_release_version \
            tag

        local stable_pattern_grep_matching_option
        if test -v tag_pattern_stable; then
            stable_pattern_grep_matching_option=
        else
            stable_pattern_grep_matching_option=--invert-match
            tag_pattern_stable="${tag_pattern_beta}|${tag_pattern_release_candidate}"
        fi

        if echo -n "${!map_of_normalized_version_to_tag[@]}" \
            | tr ' ' "\\n" \
            | grep \
                --extended-regexp \
                ${stable_pattern_grep_matching_option} \
                --quiet \
                --regexp="(${tag_pattern_stable})"; then
            local \
                last_stable_tag \
                last_stable_version \
                last_stable_version_on_the_snap_store

            last_stable_version="$(
                echo -n "${!map_of_normalized_version_to_tag[@]}" \
                    | tr ' ' "\\n" \
                    | grep \
                        --extended-regexp \
                        ${stable_pattern_grep_matching_option} \
                        --regexp="(${tag_pattern_stable})" \
                    | sort --version-sort \
                    | tail --lines=1
            )"
            last_stable_tag="${map_of_normalized_version_to_tag[${last_stable_version}]}"
            last_stable_version_on_the_snap_store="$(
                snap_query_version \
                    "${SNAPCRAFT_PROJECT_NAME}" \
                    stable \
                    "${snap_version_postfix_seperator}"
            )"
            if [ "${last_stable_version}" != "${last_stable_version_on_the_snap_store}" ]; then
                flag_version_mismatch_stable=true
            fi
        else
            if test "${flag_force_stable}" = true; then
                printf -- \
                    'selective-checkout: Error: --force-stable specified, but no stable release tags are found.\n' \
                    >&2
                exit 1
            fi
        fi

        unset \
            stable_pattern_grep_matching_option \
            tag_pattern_stable

        if echo -n "${!map_of_normalized_version_to_tag[@]}" \
            | tr ' ' "\\n" \
            | grep \
                --extended-regexp \
                --quiet \
                --regexp="${tag_pattern_release_candidate}"; then
            local \
                last_release_candidate_tag \
                last_release_candidate_version \
                last_release_candidate_version_on_the_snap_store

            last_release_candidate_version="$(
                echo -n "${!map_of_normalized_version_to_tag[@]}" \
                    | tr ' ' "\\n" \
                    | grep \
                        --extended-regexp \
                        --regexp="${tag_pattern_release_candidate}" \
                    | sort --version-sort \
                    | tail --lines=1
            )"
            last_release_candidate_tag="${map_of_normalized_version_to_tag[${last_release_candidate_version}]}"
            last_release_candidate_version_on_the_snap_store="$(
                snap_query_version \
                    "${SNAPCRAFT_PROJECT_NAME}" \
                    candidate \
                    "${snap_version_postfix_seperator}"
            )"

            if test "${last_release_candidate_version_on_the_snap_store}" != "${last_release_candidate_version}"; then
                flag_version_mismatch_release_candidate=true
            fi
        fi

        unset \
            tag_pattern_release_candidate

        if echo -n "${!map_of_normalized_version_to_tag[@]}" \
            | tr ' ' "\\n" \
            | grep \
                --extended-regexp \
                --quiet \
                --regexp="${tag_pattern_beta}"; then
            local \
                last_beta_tag \
                last_beta_version \
                last_beta_version_on_the_snap_store

            last_beta_version="$(
                echo -n "${!map_of_normalized_version_to_tag[@]}" \
                    | tr ' ' "\\n" \
                    | grep \
                        --extended-regexp \
                        --regexp="${tag_pattern_beta}" \
                    | sort --version-sort \
                    | tail --lines=1
            )"
            last_beta_tag="${map_of_normalized_version_to_tag[${last_beta_version}]}"
            last_beta_version_on_the_snap_store="$(
                snap_query_version \
                    "${SNAPCRAFT_PROJECT_NAME}" \
                    beta \
                    "${snap_version_postfix_seperator}"
            )"

            if test "${last_beta_version_on_the_snap_store}" != "${last_beta_version}"; then
                flag_version_mismatch_beta=true
            fi
        fi

        unset \
            map_of_normalized_version_to_tag \
            snap_version_postfix_seperator \
            tag_pattern_beta

        if test "${flag_version_mismatch_stable}" = true \
             || test "${flag_force_stable}" = true; then
            release_type_to_build=stable
            selected_release_tag="${last_stable_tag}"
            selected_release_version="${last_stable_version}"
            selected_snap_channel_version="${last_stable_version_on_the_snap_store}"
        elif test "${flag_version_mismatch_release_candidate}" = true; then
            release_type_to_build=release-candidate
            selected_release_tag="${last_release_candidate_tag}"
            selected_release_version="${last_release_candidate_version}"
            selected_snap_channel_version="${last_release_candidate_version_on_the_snap_store}"
        elif test "${flag_version_mismatch_beta}" = true; then
            release_type_to_build=beta
            selected_release_tag="${last_beta_tag}"
            selected_release_version="${last_beta_version}"
            selected_snap_channel_version="${last_beta_version_on_the_snap_store}"
        else
            release_type_to_build=development-snapshot
        fi

        unset \
            flag_version_mismatch_stable \
            flag_version_mismatch_beta \
            flag_version_mismatch_release_candidate \
            last_stable_tag \
            last_stable_version \
            last_stable_version_on_the_snap_store \
            last_release_candidate_tag \
            last_release_candidate_version \
            last_release_candidate_version_on_the_snap_store \
            last_beta_tag \
            last_beta_version \
            last_beta_version_on_the_snap_store


        if test "${release_type_to_build}" != development-snapshot; then
            printf -- \
                "selective-checkout: The last tagged %s release(%s) hasn't been promoted to the %s channel(%s) on the Snap Store yet, checking out %s.\\n" \
                "${release_type_to_build}" \
                "${selected_release_version}" \
                "${map_of_release_type_to_snap_channel["${release_type_to_build}"]}" \
                "${selected_snap_channel_version}" \
                "${selected_release_version}" \
                >&2
            checkout_mode=release
        else
            printf -- 'selective-checkout: Last tagged releases is all in their respective channels, building development snapshot\n' \
                >&2
            checkout_mode=snapshot
        fi

        unset \
            all_release_tags \
            map_of_release_type_to_snap_channel \
            release_type_to_build \
            selected_release_version \
            selected_snap_channel_version
    fi

    unset \
        tag_pattern_release

    case "${checkout_mode}" in
        snapshot)
            : # do nothing
        ;;
        release)
            vcs_checkout_tag \
                "${PWD}" \
                "${selected_release_tag}"
        ;;
        *)
            printf -- 'Error: Invalid checkout_mode selected.\n' >&2
            exit 1
        ;;
    esac

    unset \
        checkout_mode \
        selected_release_tag

    upstream_version="$(
        vcs_describe_version \
            "${PWD}" \
            "${revision_minimal_length_upstream}" \
            "${postfix_dirty_marker_upstream}" \
            | sed "s#^${tag_prefix_release}##"
    )"

    if test "${flag_append_packaging_version}" = true; then
        # WORKAROUND:
        #   Allow fetching project revision in multipass build
        #   environment, which uses out-of-tree build and packaging
        #   source tree repo location can't be determined via environment
        #   Unable to determine project version info in multipass build environment - snapcraft - snapcraft.io
        #   https://forum.snapcraft.io/t/unable-to-determine-project-version-info-in-multipass-build-environment/10416
        if test -d /root/project; then
            packaging_source_tree_root_dir=/root/project
        else
            # parts/_part_name_/src
            packaging_source_tree_root_dir=../../..
        fi

        packaging_revision="$(
            vcs_describe_revision \
                "${packaging_source_tree_root_dir}" \
                "${revision_minimal_length_packaging}" \
                "${postfix_dirty_marker_packaging}"
        )"
        snap_version="${upstream_version}+pkg-${packaging_revision}"
        unset \
            packaging_revision \
            packaging_source_tree_root_dir \
            postfix_dirty_marker_packaging \
            revision_minimal_length_packaging
    else
        snap_version="${upstream_version}"
    fi
    unset \
        postfix_dirty_marker_upstream \
        revision_minimal_length_upstream \
        tag_prefix_release \
        upstream_version

    printf -- 'selective-checkout: Snap version determined to be "%s".\n' \
        "${snap_version}" >&2
    if test "${flag_dry_run}" = false; then
        snapcraftctl \
            set-version \
            "${snap_version}"
    fi
    exit 0
}

# Query snap version for specific channel
# FIXME: Instead of parsing the `snap info` command's output we should
# parse the structural data output from the Snapd API instead, but it
# is a dependency breaking change that should be dealt properly...
snap_query_version(){
    if test $# -ne 3; then
        printf 'FATAL: %s: Parameter quantity mismatch.\n' "${FUNCNAME[0]}" >&2
        exit 1
    fi

    local snap_identifier="${1}"; shift
    local release_channel="${1}"; shift
    local snap_version_postfix_seperator="${1}"; shift

    snap info "${snap_identifier}" \
        | awk \
            "\$1 == \"${release_channel}:\" { print \$2 }" \
        | cut \
            --delimiter="${snap_version_postfix_seperator}" \
            --fields=1 \
        || true # Allow the command to fail, it will make the version mismatch nonetheless
}

# Determine which VCS is used
# FIXME: Allow specifying any node under the working directory, not just the root node
vcs_detect(){
    if test $# -ne 1; then
        printf 'FATAL: %s: Parameter quantity mismatch.\n' "${FUNCNAME[0]}" >&2
        exit 1
    fi

    local source_tree_root_dir="${1}"; shift 1

    if test -e "${source_tree_root_dir}"/.git; then
        printf git
    elif test -e "${source_tree_root_dir}"/.hg; then
        printf mercurial
    elif test -e "${source_tree_root_dir}"/.svn; then
        printf subversion
    else
        printf not_found
    fi
}

# Ensure depending software is available before using them
vcs_check_runtime_dependencies(){
    if test $# -ne 1; then
        printf 'FATAL: %s: Parameter quantity mismatch.\n' "${FUNCNAME[0]}" >&2
        exit 1
    fi

    local -r source_tree_root_dir="${1}"; shift 1

    case "$(vcs_detect "${source_tree_root_dir}")" in
        git)
            if ! command -v git &>/dev/null; then
                # Markdown code markup is not Bash tilde expression
                # shellcheck disable=SC2016
                printf -- \
                    '%s: Error: `git` command not found in the command search PATHs.\n' \
                    "${FUNCNAME[0]}" \
                    >&2
                return 1
            fi
        ;;
        mercurial)
            if ! command -v hg &>/dev/null; then
                # Markdown code markup is not Bash tilde expression
                # shellcheck disable=SC2016
                printf -- \
                    '%s: Error: `hg` command not found in the command search PATHs.\n' \
                    "${FUNCNAME[0]}" \
                    >&2
                return 1
            fi
        ;;
        subversion)
            if ! command -v svn &>/dev/null; then
                # Markdown code markup is not Bash tilde expression
                # shellcheck disable=SC2016
                printf -- \
                    '%s: Error: `svn` command not found in the command search PATHs.\n' \
                    "${FUNCNAME[0]}" \
                    >&2
                return 1
            fi
        ;;
        *)
            printf -- \
                '%s: Warning: Unknown VCS type, assuming none.\n' \
                "${FUNCNAME[0]}" \
                >&2
            return 0
        ;;
    esac
}

vcs_is_dirty(){
    if test $# -ne 1; then
        printf 'FATAL: %s: Parameter quantity mismatch.\n' "${FUNCNAME[0]}" >&2
        exit 1
    fi

    local -r source_tree_root_dir="${1}"; shift 1

    case "$(vcs_detect "${source_tree_root_dir}")" in
        git)
            # If tracked files are modified
            # or staging area not empty
            if ! \
                git -C "${source_tree_root_dir}" diff \
                    --quiet \
                || ! \
                git -C "${source_tree_root_dir}"  diff \
                    --staged \
                    --quiet; then
                return 0
            else
                return 1
            fi
        ;;
        mercurial)
            # NOTE:
            # The existence of untracked files is not consider dirty,
            # imitating Git's `--dirty` option of the describe
            # subcommand
            if test -n "$(
                hg --cwd "${source_tree_root_dir}" status \
                    --added \
                    --deleted \
                    --modified \
                    --removed
            )"; then
                return 0
            else
                return 1
            fi
        ;;
        subversion)
            # NOTE: Is there any straightforward way to check this?
            if test -n "$(
                svn status -q
            )"; then
                return 0
            else
                return 1
            fi
        ;;
        *)
            printf -- \
                '%s: Warning: Unknown VCS type, assuming dirty.\n' \
                "${FUNCNAME[0]}" \
                >&2
            return 0
        ;;
    esac
}

vcs_has_release_tags() {
    if test $# -ne 2; then
        printf 'FATAL: %s: Parameter quantity mismatch.\n' "${FUNCNAME[0]}" >&2
        exit 1
    fi

    local -r source_tree_root_dir="${1}"; shift 1

    # Pattern to match a release tag, in extended regular expression(ERE)
    local -r tag_pattern_release="${1}"; shift 1

    case "$(vcs_detect "${source_tree_root_dir}")" in
        git)
            if git -C "${source_tree_root_dir}" tag \
                --list \
                | grep \
                    --extended-regexp \
                    --quiet \
                    --regexp="${tag_pattern_release}"; then
                return 0
            else
                return 1
            fi
        ;;
        mercurial)
            if hg --cwd "${source_tree_root_dir}" tags \
                | grep \
                    --extended-regexp \
                    --quiet \
                    --regexp="${tag_pattern_release}"; then
                return 0
            else
                return 1
            fi
        ;;
        subversion)
            local \
                source_tree_root_url \
                tags_dir_url

            source_tree_root_url="$(
                svn info \
                    --show-item url \
                     "${source_tree_root_dir}"
            )"

            # Supported source URLs:
            # * /trunk
            # * /tags/_tag_name_
            case "${source_tree_root_url}" in
                */trunk)
                    # Strip trailing shortest matched pattern
                    # https://www.gnu.org/software/bash/manual/html_node/Shell-Parameter-Expansion.html
                    tags_dir_url="${source_tree_root_url%/trunk}/tags"
                ;;
                */tags/*)
                    tags_dir_url="${source_tree_root_url%/*}"
                ;;
                *)
                    printf -- \
                        'Warning: %s: Unsupported SVN source URL, assuming no release tags found.\n' \
                        "${FUNCNAME[0]}" \
                        >&2
                    return 1
                ;;
            esac

            if svn list \
                "${tags_dir_url}" \
                | sed 's#/$##' \
                | grep \
                    --extended-regexp \
                    --quiet \
                    --regexp="${tag_pattern_release}"; then
                return 0
            else
                return 1
            fi
        ;;
        *)
            printf -- \
                '%s: Warning: Unknown VCS type, assuming no release tags found.\n' \
                "${FUNCNAME[0]}" \
                >&2
            return 1
        ;;
    esac
}

vcs_query_release_tags(){
    if test $# -ne 2; then
        printf 'FATAL: %s: Parameter quantity mismatch.\n' "${FUNCNAME[0]}" >&2
        exit 1
    fi

    local -r source_tree_root_dir="${1}"; shift 1

    # Pattern to match a release tag, in extended regular expression(ERE)
    local -r tag_pattern_release="${1}"; shift 1

    case "$(vcs_detect "${source_tree_root_dir}")" in
        git)
            if git -C "${source_tree_root_dir}" tag \
                --list \
                | grep \
                    --extended-regexp \
                    --regexp="${tag_pattern_release}"; then
                return 0
            else
                return 1
            fi
        ;;
        mercurial)
            if hg --cwd "${source_tree_root_dir}" tags \
                --quiet \
                | grep \
                    --extended-regexp \
                    --regexp="${tag_pattern_release}"; then
                return 0
            else
                return 1
            fi
        ;;
        subversion)
            local \
                source_tree_root_url \
                tags_dir_url

            source_tree_root_url="$(
                svn info \
                    --show-item url \
                     "${source_tree_root_dir}"
            )"

            # Supported source URLs:
            # * /trunk
            # * /tags/_tag_name_
            case "${source_tree_root_url}" in
                */trunk)
                    # Strip trailing shortest matched pattern
                    # https://www.gnu.org/software/bash/manual/html_node/Shell-Parameter-Expansion.html
                    tags_dir_url="${source_tree_root_url%/trunk}/tags"
                ;;
                */tags/*)
                    tags_dir_url="${source_tree_root_url%/*}"
                ;;
                *)
                    printf -- \
                        'Warning: %s: Unsupported SVN source URL, assuming no release tags found.\n' \
                        "${FUNCNAME[0]}" \
                        >&2
                    return 1
                ;;
            esac

            if svn list \
                "${tags_dir_url}" \
                | sed 's#/$##' \
                | grep \
                    --extended-regexp \
                    --regexp="${tag_pattern_release}"; then
                return 0
            else
                return 1
            fi
        ;;
        *)
            printf -- \
                '%s: Warning: Unknown VCS type, assuming no release tags found.\n' \
                "${FUNCNAME[0]}" \
                >&2
            return 1
        ;;
    esac
}

vcs_checkout_tag(){
    if test $# -ne 2; then
        printf 'FATAL: %s: Parameter quantity mismatch.\n' "${FUNCNAME[0]}" >&2
        exit 1
    fi

    local -r source_tree_root_dir="${1}"; shift 1
    local -r tag_to_be_checked_out="${1}"; shift 1

    case "$(vcs_detect "${source_tree_root_dir}")" in
        git)
            git -C "${source_tree_root_dir}" checkout \
                "${tag_to_be_checked_out}"
            return 0
        ;;
        mercurial)
            hg --cwd "${source_tree_root_dir}" checkout \
                --rev "${tag_to_be_checked_out}"
            return 0
        ;;
        subversion)
            local \
                source_tree_root_url \
                tags_dir_url

            source_tree_root_url="$(
                svn info \
                    --show-item url \
                     "${source_tree_root_dir}"
            )"

            # Supported source URLs:
            # * /trunk
            # * /tags/_tag_name_
            case "${source_tree_root_url}" in
                */trunk)
                    # Strip trailing shortest matched pattern
                    # https://www.gnu.org/software/bash/manual/html_node/Shell-Parameter-Expansion.html
                    tags_dir_url="${source_tree_root_url%/trunk}/tags"
                ;;
                */tags/*)
                    tags_dir_url="${source_tree_root_url%/*}"
                ;;
                *)
                    printf -- \
                        'Warning: %s: Unsupported SVN source URL, assuming check out failed.\n' \
                        "${FUNCNAME[0]}" \
                        >&2
                    return 1
                ;;
            esac

            if svn checkout \
                "${tags_dir_url}"/"${tag_to_be_checked_out}"; then
                return 0
            else
                return 1
            fi
        ;;
        *)
            printf -- \
                '%s: Warning: Unknown VCS type, not doing anything.\n' \
                "${FUNCNAME[0]}" \
                >&2
            return 1
        ;;
    esac
}

# Describe software version, use tags when available
vcs_describe_version(){
    if test $# -ne 3; then
        printf 'FATAL: %s: Parameter quantity mismatch.\n' "${FUNCNAME[0]}" >&2
        exit 1
    fi

    local -r source_tree_root_dir="${1}"; shift 1
    local -r revision_identifier_length_minimum="${1}"; shift 1
    local -r dirty_postfix="${1}"; shift 1

    case "$(vcs_detect "${source_tree_root_dir}")" in
        git)
            git describe \
                --abbrev="${revision_identifier_length_minimum}" \
                --always \
                --dirty="${dirty_postfix}" \
                --tags
            return 0
        ;;
        mercurial)
            hg --cwd "${source_tree_root_dir}" log \
                --rev . \
                --template "{latesttag}{sub('^-0-.*', '', '-{latesttagdistance}-m{shortest(node, ${revision_identifier_length_minimum})}')}"
            if vcs_is_dirty "${source_tree_root_dir}"; then
                printf -- %s "${dirty_postfix}"
            fi
            return 0
        ;;
        subversion)
            local \
                source_tree_root_url

            source_tree_root_url="$(
                svn info \
                    --show-item url \
                     "${source_tree_root_dir}"
            )"

            # Supported source URLs:
            # * /trunk
            # * /tags/_tag_name_
            case "${source_tree_root_url}" in
                */trunk)
                    printf %s \
                        "rev$(
                            svn info \
                                --show-item revision \
                                "${source_tree_root_dir}"
                        )"
                ;;
                */tags/*)
                    local tag
                    tag="${source_tree_root_url##*/}"
                    printf %s "${tag}"
                ;;
                *)
                    printf -- \
                        'Warning: %s: Unsupported SVN source URL.\n' \
                        "${FUNCNAME[0]}" \
                        >&2
                    printf unknown
                    return 1
                ;;
            esac

            if vcs_is_dirty "${source_tree_root_dir}"; then
                printf -- %s "${dirty_postfix}"
            fi
        ;;
        *)
            printf -- \
                '%s: Warning: Unknown VCS type.\n' \
                "${FUNCNAME[0]}" \
                >&2
            printf unknown
            return 0
        ;;
    esac
}

# Describe version control revision, only revision identifier/hash with
# customizable minimum length
# FIXME: Some node among source tree should be enough for source_tree_root_dir
vcs_describe_revision(){
    if test $# -ne 3; then
        printf 'FATAL: %s: Parameter quantity mismatch.\n' "${FUNCNAME[0]}" >&2
        exit 1
    fi

    local -r source_tree_root_dir="${1}"; shift 1
    local -r revision_identifier_length_minimum="${1}"; shift 1
    local -r dirty_postfix="${1}"; shift 1

    case "$(vcs_detect "${source_tree_root_dir}")" in
        git)
            if ! git -C "${source_tree_root_dir}" describe --always >/dev/null; then
                printf unknown
            else
                git -C "${source_tree_root_dir}" describe \
                    --abbrev="${revision_identifier_length_minimum}" \
                    --always \
                    --dirty="${dirty_postfix}" \
                    --match=nothing
            fi
            return 0
        ;;
        mercurial)
            if ! hg --cwd "${source_tree_root_dir}" status >/dev/null; then
                printf unknown
            else
                # FIXME: Is there a better way of generating this only using Mercurial?
                local hg_revision

                hg_revision+="$(
                    hg --cwd "${source_tree_root_dir}" log \
                        --rev . \
                        --template "{shortest(node, ${revision_identifier_length_minimum})}"
                )"

                if vcs_is_dirty "${source_tree_root_dir}"; then
                    hg_revision+="${dirty_postfix}"
                fi

                printf -- %s "${hg_revision}"
            fi
            return 0
        ;;
        subversion)
            svn info \
                --show-item revision \
                    "${source_tree_root_dir}"

            if vcs_is_dirty "${source_tree_root_dir}"; then
                printf -- %s "${dirty_postfix}"
            fi
        ;;
        *)
            printf -- \
                '%s: Warning: Unknown VCS type.\n' \
                "${FUNCNAME[0]}" \
                >&2
            printf unknown
            return 0
        ;;
    esac
}

init "${@}"
